# Producer-Consumer Project ðŸ’«âœ¨

**By:** Thandokuhle Msane and Thandolwethu Nhlabatsi \
**Course:** CSC411 - Integrative Programming Technologies \
**Institution:** University of Eswatini

## Assignment Overview

This project is a practical implementation of the **Producer-Consumer Problem**, a classic synchronization problem in Operating Systems. We have implemented this using **Python**, utilizing **Socket Programming** for communication between processes , **XML** for data exchange, and **Semaphores** for concurrency control.

The goal is to safely share a finite buffer between a Producer (who generates student data) and a Consumer (who processes results) without data loss or _race conditions_.

## Theoretical Concepts

To understand this implementation, it is essential to understand the underlying Operating Systems concepts:

### 1. The Producer-Consumer Problem

This is a synchronization problem where two processes, the **Producer** and the **Consumer**, share a common, fixed-size buffer.

- **The Producer's Job:** Generate data, put it into the buffer and signals in the queue that there is data available for the consumer to process.
- **The Consumer's Job:** Remove data from the buffer and process it.
- **The Problem:** We must make sure the Producer doesn't try to add data to a full buffer and the Consumer doesn't try to remove data from an empty buffer.

### 2. Queues (The Buffer)

We use a **FIFO (First-In-First-Out) Queue** to act as the shared buffer. It is a "bounded buffer," meaning it has a strict limit on how many items it can hold (Maximum 10 elements).

### 3. Critical Section

The **Critical Section** is a part of the code where the process accesses a shared resource (in our case, the `buffer_queue`). Only one process can execute in the critical section at a time to prevent data corruption. This section is in contrast to other sections like entry section, exit section, and remainder section which are also essential for understanding process synchronization.

- **Requirement:** Access to the shared buffer must be mutually **_exclusive_**.

### 4. Semaphores

Semaphores are signaling mechanisms used to control access to the critical section. In this project, we use three specific semaphores:

- **`mutex` (Mutual Exclusion):** Acts like a lock. It ensures that only one thread accesses the buffer at a time.
- **`empty_slots`:** Counts how many spots are open in the buffer. The Producer waits on this if the buffer is full.
- **`filled_slots`:** Counts how many items are currently in the buffer. The Consumer waits on this if the buffer is empty.

### 5. Threading & Sockets

- **Socket Programming:** Allows our Producer, Consumer, and Server to run as separate processes and communicate over a network.
- **Threading:** The Server uses threads to handle multiple connections simultaneously, allowing the Producer and Consumer to interact with the buffer at the same time.

## Implementation Details

### 1. The Server (`server.py`) - The Buffer Manager

The Server acts as the "Middle Man" managing the shared resources.

- It initializes the `Queue` (size 10).
- It manages the **Semaphores** to enforce synchronization rules.
- It listens for connections from the Producer and Consumer using Sockets.

### 2. The Producer (`producer.py`)

The Producer generates student information using the `ITstudent` class.

- **Data Generation:** Randomly generates Student Name, ID (8 digits), Programme, and Courses with marks.
- **XML Wrapping:** Wraps this data into an XML file (e.g., `student1.xml`).
- **Schema Validation:** Ensures the XML follows the strict `student.xsd` schema.
- **Shared Storage:** Saves the XML file to the shared `../buffer` directory.
- **Notification:** Sends the **file ID** (integer) to the Server to be added to the queue.

### 3. The Consumer (`consumer.py`)

The Consumer processes the data generated by the Producer.

- **Request:** Asks the Server for a file ID. If the buffer is empty, the Consumer waits.
- **Unwrapping:** Reads the corresponding XML file from the shared directory and parses it back into an `ITstudent` class.
- **Cleanup:** Deletes the XML file from the directory and the ID is removed from the buffer.
- **Processing:**
  - Calculates the average mark.
  - Determines Pass/Fail status where 50% is the passing mark.
  - Prints, on standard output, the Student Name, ID, Programme, Courses, Marks, and Status to the screen.

## ðŸ§° Tools & Technologies Used

- **Python 3.14:** An intepreter-based programming language.
- **Socket API:** For implementing the TCP/IP connection between the three scripts.
- **XML (Extensible Markup Language):** Used for structuring the student data for storage.
- **XSD (XML Schema Definition):** Used to validate the structure of the generated XML files.
- **GitHub:** Used for version control and collaboration.
- **Threading & Queue Modules:** Python's built-in libraries for handling concurrency.

## ðŸ“‚ Project Structure

```text
Producer-Consumer/
â”‚
â”œâ”€â”€ buffer/                # Shared directory for XML files which acts as a buffer
â”œâ”€â”€ src/
  â”œâ”€â”€ .venv/               # Python virtual environment folder
  â”œâ”€â”€ server.py            # Holds the Buffer, Semaphores, and Socket Server
  â”œâ”€â”€ producer.py          # Generates data and XML files
  â”œâ”€â”€ consumer.py          # Reads XML, calculates grades, prints reports
  â”œâ”€â”€ utils.py             # Contains ITstudent class and XML logic
  â”œâ”€â”€ config.py            # Shared settings (IP, Port, File paths)
  â”œâ”€â”€ main.py              # runs the producer, consumer and server processes using threads
  â”œâ”€â”€ student.xsd          # XML Schema for validation
  â”œâ”€â”€ pyproject.toml       # requirements file for both development dependencies like `pre-commit` and `ruff` for code linting
  â”œâ”€â”€ uv.lock              # `uv` dependency management file
â””â”€â”€ README.md              # Project Documentation
```
